#!/usr/bin/python
# This script generates a file with toy sequences for the regression task.
# The sequences are generated by drawing each symbol from an uniform distribution over a given alphabet.
# In each sequence motifs are inserted.
# For each sequence the response variable is computed by the regression equation.
# Additionally a test with 0.25 number of sequences as the trainig set is created.
#
# Usage: ./generateToySequence -n <number of sequences> -l <length
# of sequences> -A <Number of seuqneces> -s <Alphabet Size> -o
# <outputfile> -a <motif length>
#

import sys
import numpy as np
import getopt
import random

ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ012345'
# Gather our code in a main() function

def generate_string(length, alphabet_size):
    return ''.join(random.choice(ALPHABET[:alphabet_size]) for _ in range(length))

def generate_motifs(number, length, alphabet_size):
    motifs_list = []
    # motifs = np.dtype([number])
    for index in range(number):
        motif = generate_string(length, alphabet_size)
        motifs_list.append(motif)
    return motifs_list


def generate_sequences(num_seq, seq_length,  motifs, values, alphSize, f):
    # Generate sequences and response
    motif_length = len(motifs[0])
    num_motifs = len(motifs)
    noise = np.random.normal(0, 1, num_seq)
    additional_file = open(f.name + ".contains", 'w')
    num_recomput = 0
    for j in range(0, num_seq):
        # Vector indicating which motifs are included
        contains = np.random.rand(len(motifs), 1).round()

        # Calculate effective generated length
        num_motifs_in_seq = np.trunc(sum(contains)).astype(int)
        effLen = seq_length - (num_motifs_in_seq *
                               motif_length) + num_motifs_in_seq
        bias = 0
        # Regression equation
        y = np.dot(values, contains) + noise[j] + bias

        # Write reponse
        f.write(" ".join(map(str, y)) + " ")
        # Draw position for insertion of motifs
        motif_positions = np.random.randint(0, effLen - 1, num_motifs)
        # contains * motif_positions

        seq = {}
        for i in range(contains.size):
            if contains[i, 0] == 1:
                if str(motif_positions[i]) in seq:
                    seq[str(motif_positions[i])].append(motifs[i])
                else:
                    seq[str(motif_positions[i])] = [motifs[i]]
        # Write sequence
        s = ""
        for i in range(0, effLen[0]):
            if (str(i) in seq):
                for motif in seq[str(i)]:
                    s += motif
            else:
                randN = np.random.randint(0, alphSize)
                s += ALPHABET[randN]

        s = repair_sequence(s, contains, motifs, alphSize)
        f.write(s)

        # Write additional information for debuging
        for i in range(contains.size):
            if contains[i, 0] == 1:
                additional_file.write(motifs[i])
                additional_file.write(" ")
        f.write("\n")
        additional_file.write("\n")
    additional_file.close()


def repair_sequence(sequence, contains, motifs, alphabet_size):
    had_conflict = False
    i = 0
    while i < contains.size:
        if contains[i, 0] == 0:
            while sequence.find(motifs[i]) != -1:
                sequence = sequence.replace(motifs[i],
                                       generate_string(len(motifs[i]), alphabet_size),
                                       1)
                had_conflict = True
        i += 1

    if had_conflict:
        return repair_sequence(sequence, contains, motifs, alphabet_size)
    else:
        return sequence

def main():
    # Set defaults
    numSeq = 200
    outputFile = "toySequence"
    length = 50
    alphSize = 4
    # Probability motif get inserted (independent of each other)
    num_motifs = 0
    # Read arguments
    try:
        opts, args = getopt.getopt(sys.argv[1:], "h:n:l:s:o:a:A:", [
            "numSeq=", "length=", "alphabetSize=", "outputfile=", "motiflength=", "numMotifs="])
    except getopt.GetoptError:
        print(sys.argv[0], '-n <Number seq> -l <length of sequences> -s <Alphabet Size> -o <outputfile> -a <motiflength> -A <NUmber of Motifs>')
        sys.exit(2)
    for opt, arg in opts:
        if opt == '-h':
            print(sys.argv[0],
                  '-n <Number seq> -l <length of sequences> -s <Alphabet Size> -o <outputfile> -a <motiflength> -A <Number of Motifs>')
            sys.exit()
        elif opt in ("-n", "--numSeq"):
            numSeq = int(arg)
        elif opt in ("-l", "--length"):
            length = int(arg)
        elif opt in ("-s", "--alphabetSize"):
            alphSize = int(arg)
            if alphSize > 33:
                print("alphabet size is to big (>32)")
                sys.exit()
        elif opt in ("-a", "--motiflength"):
            motif_length = int(arg)
        elif opt in ("-A", "--numMotifs"):
            num_motifs = int(arg)
        elif opt in ("-o", "--outputFile"):
            outputFile = arg

    with open(outputFile + ".train", 'w') as f:
        np.random.seed()

        # Generate the motifs randomly and write the generated motif to the files
        # motif(A|B) if generateMotif is set
        if motif_length <= 0:
            print("You have defined a motif lengths that is lower than 0")
            exit(-1)
        motifs = generate_motifs(num_motifs, motif_length, alphSize)
        values = np.random.normal(0, 5, num_motifs)
        correctModelFile = open("correctModel", 'w')
        for i in range(len(motifs)):
            correctModelFile.write(str(motifs[i]) + " ")
            correctModelFile.write(str(values[i]) + "\n")
        correctModelFile.close()
        generate_sequences(numSeq, length, motifs, values, alphSize, f)

    with open(outputFile + ".test", 'w') as f:
        generate_sequences(numSeq / 25, length, motifs, values, alphSize, f)


if __name__ == '__main__':
    main()
